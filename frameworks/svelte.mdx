---
title: 'Svelte & SvelteKit Integration'
description: 'Integrate WebMCP tools with Svelte and SvelteKit. Use Svelte 5 runes or stores for reactive tool registration with automatic cleanup.'
icon: 'code'
---

## Overview

Svelte's reactive primitives make WebMCP integration straightforward. This guide covers both Svelte 5 (with runes) and Svelte 4 (with stores), plus SvelteKit-specific patterns for SSR.

## How It Works

When you import `@mcp-b/global`, your Svelte app starts an **MCP server**:

1. **MCP server starts** - `navigator.modelContext` is initialized with `TabServerTransport`
2. **Tools are registered** - Your components call `registerTool()` to expose functionality
3. **AI agents connect** - External agents use `TabClientTransport` to discover and call tools

For SvelteKit with SSR, ensure WebMCP code only runs on the client using `onMount` or the `browser` check.

## Prerequisites

<Steps>
  <Step title="Install WebMCP">
    ```bash
    npm install @mcp-b/global
    ```
  </Step>

  <Step title="Initialize in your app">
    Import once at your app's entry point to start the MCP server:

    ```typescript
    import '@mcp-b/global'; // Starts MCP server
    ```
  </Step>
</Steps>

<Info>
  For schema validation, see [Schemas Guide](/concepts/schemas).
</Info>

## Svelte Action

Svelte actions provide a clean way to add WebMCP functionality:

```typescript "lib/actions/webmcp.ts"
import '@mcp-b/global';

interface ToolConfig {
  name: string;
  description: string;
  inputSchema?: Record<string, unknown>;
  handler: (args: Record<string, unknown>) => Promise<unknown>;
}

export function webmcp(node: HTMLElement, config: ToolConfig) {
  let registration: { unregister: () => void } | null = null;

  function register(cfg: ToolConfig) {
    if (!('modelContext' in navigator)) return;

    registration = navigator.modelContext.registerTool({
      name: cfg.name,
      description: cfg.description,
      inputSchema: cfg.inputSchema ?? { type: 'object', properties: {} },
      async execute(args) {
        const result = await cfg.handler(args);
        return {
          content: [{
            type: 'text',
            text: typeof result === 'string' ? result : JSON.stringify(result)
          }]
        };
      }
    });
  }

  register(config);

  return {
    update(newConfig: ToolConfig) {
      registration?.unregister();
      register(newConfig);
    },
    destroy() {
      registration?.unregister();
    }
  };
}
```

### Using the Action

```svelte "ProductCard.svelte"
<script lang="ts">
  import { webmcp } from '$lib/actions/webmcp';

  export let product: { id: string; name: string; price: number };
</script>

<div
  use:webmcp={{
    name: `view_product_${product.id}`,
    description: `View details for ${product.name}`,
    handler: async () => ({
      id: product.id,
      name: product.name,
      price: product.price
    })
  }}
>
  <h3>{product.name}</h3>
  <p>${product.price}</p>
</div>
```

## Svelte 5 Runes

Create a reactive integration using Svelte 5 runes:

```typescript "lib/webmcp.svelte.ts"
import { onMount, onDestroy } from 'svelte';
import '@mcp-b/global';

interface ToolConfig {
  name: string;
  description: string;
  inputSchema?: Record<string, unknown>;
  handler: (args: Record<string, unknown>) => Promise<unknown>;
}

export function useWebMCP(config: ToolConfig): void {
  let registration: { unregister: () => void } | null = null;

  onMount(() => {
    if (typeof window === 'undefined' || !('modelContext' in navigator)) return;

    registration = navigator.modelContext.registerTool({
      name: config.name,
      description: config.description,
      inputSchema: config.inputSchema ?? { type: 'object', properties: {} },
      execute: async (args) => {
        const result = await config.handler(args);
        return {
          content: [{
            type: 'text',
            text: typeof result === 'string' ? result : JSON.stringify(result)
          }]
        };
      }
    });
  });

  onDestroy(() => {
    registration?.unregister();
  });
}
```

<Info>
  **How AI agents call your tools**: AI agents use `TabClientTransport` to connect to your page and call `client.listTools()` to discover available tools, then `client.callTool()` to execute them. See [Transports](/packages/transports) for details.
</Info>

```svelte "Counter.svelte"
<script lang="ts">
  import { useWebMCP } from '$lib/webmcp.svelte';

  let count = $state(0);

  useWebMCP({
    name: 'increment_count',
    description: 'Increment the counter',
    inputSchema: {
      type: 'object',
      properties: {
        amount: { type: 'number', description: 'Amount to increment' }
      }
    },
    handler: async ({ amount = 1 }) => {
      count += amount as number;
      return { newCount: count };
    }
  });
</script>

<div>
  <p>Count: {count}</p>
</div>
```

## SvelteKit SSR

SvelteKit renders on the server by default. Use `onMount` or `browser` checks:

```svelte "+page.svelte"
<script lang="ts">
  import { browser } from '$app/environment';
  import { onMount, onDestroy } from 'svelte';
  import '@mcp-b/global';

  export let data; // From +page.server.ts

  let registration: { unregister: () => void } | null = null;

  onMount(() => {
    if (!browser || !('modelContext' in navigator)) return;

    registration = navigator.modelContext.registerTool({
      name: 'search_products',
      description: 'Search loaded products',
      inputSchema: {
        type: 'object',
        properties: { query: { type: 'string' } },
        required: ['query']
      },
      async execute(args) {
        const results = data.products.filter(p =>
          p.name.toLowerCase().includes((args.query as string).toLowerCase())
        );
        return { content: [{ type: 'text', text: JSON.stringify(results) }] };
      }
    });
  });

  onDestroy(() => registration?.unregister());
</script>
```

## Layout-Level Tools

Register global tools in your layout:

```svelte "+layout.svelte"
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { goto } from '$app/navigation';
  import '@mcp-b/global';

  let registrations: Array<{ unregister: () => void }> = [];

  onMount(() => {
    if (!('modelContext' in navigator)) return;

    registrations.push(
      navigator.modelContext.registerTool({
        name: 'navigate',
        description: 'Navigate to a page',
        inputSchema: {
          type: 'object',
          properties: { path: { type: 'string' } },
          required: ['path']
        },
        async execute(args) {
          await goto(args.path as string);
          return { content: [{ type: 'text', text: `Navigated to ${args.path}` }] };
        }
      })
    );
  });

  onDestroy(() => registrations.forEach(r => r.unregister()));
</script>

<slot />
```

## Store Integration

Integrate tools with Svelte stores:

```typescript "lib/stores/cart.ts"
import { writable, get } from 'svelte/store';
import '@mcp-b/global';

function createCartStore() {
  const { subscribe, update } = writable<Array<{ id: string; quantity: number }>>([]);

  return {
    subscribe,
    addItem: (id: string, quantity: number) => update(items => {
      const existing = items.find(i => i.id === id);
      if (existing) existing.quantity += quantity;
      else items.push({ id, quantity });
      return [...items];
    }),

    registerTools: () => {
      if (typeof window === 'undefined' || !('modelContext' in navigator)) {
        return () => {};
      }

      const reg = navigator.modelContext.registerTool({
        name: 'cart_view',
        description: 'View cart contents',
        inputSchema: { type: 'object', properties: {} },
        async execute() {
          return { content: [{ type: 'text', text: JSON.stringify(get({ subscribe })) }] };
        }
      });

      return () => reg.unregister();
    }
  };
}

export const cart = createCartStore();
```

## Common Gotchas

<AccordionGroup>
  <Accordion title="'navigator is not defined' during SSR">
    Use `browser` check or `onMount`:

    ```typescript
    import { browser } from '$app/environment';

    if (browser && 'modelContext' in navigator) {
      // Safe to use WebMCP
    }
    ```

    See [Framework Gotchas](/ai-frameworks/framework-gotchas) for more patterns.
  </Accordion>

  <Accordion title="Stale state in handlers">
    Read state inside the handler:

    ```typescript
    // Svelte 5: Access rune directly
    handler: async () => ({ count })

    // Svelte 4: Use get()
    handler: async () => ({ count: get(countStore) })
    ```
  </Accordion>

  <Accordion title="Tools disappear after navigation">
    Move registration to `+layout.svelte` for persistence across routes.
  </Accordion>
</AccordionGroup>

## Resources

<CardGroup cols={2}>
  <Card title="Svelte Docs" icon="book" href="https://svelte.dev/docs">
    Official Svelte documentation
  </Card>

  <Card title="SvelteKit Docs" icon="book" href="https://kit.svelte.dev/docs">
    Official SvelteKit documentation
  </Card>

  <Card title="Transports" icon="plug" href="/packages/transports">
    TabClientTransport and TabServerTransport reference
  </Card>

  <Card title="AI Frameworks" icon="sparkles" href="/ai-frameworks">
    Integrate with Assistant-UI, AG-UI, or custom runtimes
  </Card>
</CardGroup>
