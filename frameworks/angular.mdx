---
title: 'Angular Integration'
description: 'Integrate WebMCP tools with Angular using services and lifecycle hooks.'
icon: 'angular'
---

<Info>
**Prerequisites**: Install `@mcp-b/global` per the [Global Package docs](/packages/global). For the full API, see [Tool Registration](/concepts/tool-registration).
</Info>

## Basic Component Usage

```typescript "my.component.ts"
import { Component, OnInit, OnDestroy } from '@angular/core';
import '@mcp-b/global';

@Component({
  selector: 'app-my',
  template: `<p>Count: {{ count }}</p>`
})
export class MyComponent implements OnInit, OnDestroy {
  count = 0;
  private reg: { unregister: () => void } | null = null;

  ngOnInit() {
    if (!('modelContext' in navigator)) return;

    this.reg = navigator.modelContext.registerTool({
      name: 'increment',
      description: 'Increment the counter',
      inputSchema: {
        type: 'object',
        properties: { amount: { type: 'number' } }
      },
      execute: async ({ amount = 1 }) => {
        this.count += amount as number;
        return { content: [{ type: 'text', text: `Count: ${this.count}` }] };
      }
    });
  }

  ngOnDestroy() {
    this.reg?.unregister();
  }
}
```

## SSR-Safe (Angular Universal)

Use `isPlatformBrowser` for SSR safety:

```typescript
import { Component, OnInit, OnDestroy, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import '@mcp-b/global';

@Component({
  selector: 'app-my',
  template: `<p>Content</p>`
})
export class MyComponent implements OnInit, OnDestroy {
  private reg: { unregister: () => void } | null = null;
  private isBrowser: boolean;

  constructor(@Inject(PLATFORM_ID) platformId: object) {
    this.isBrowser = isPlatformBrowser(platformId);
  }

  ngOnInit() {
    if (!this.isBrowser || !('modelContext' in navigator)) return;

    this.reg = navigator.modelContext.registerTool({
      name: 'my_tool',
      description: 'My tool',
      inputSchema: { type: 'object', properties: {} },
      execute: async () => ({ content: [{ type: 'text', text: 'Done' }] })
    });
  }

  ngOnDestroy() {
    this.reg?.unregister();
  }
}
```

## Creating a Service

For reuse across components:

```typescript "webmcp.service.ts"
import { Injectable, OnDestroy, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import '@mcp-b/global';

@Injectable({ providedIn: 'root' })
export class WebMCPService implements OnDestroy {
  private registrations = new Map<string, { unregister: () => void }>();
  readonly isAvailable: boolean;

  constructor(@Inject(PLATFORM_ID) platformId: object) {
    this.isAvailable = isPlatformBrowser(platformId) && 'modelContext' in navigator;
  }

  register(tool: Parameters<typeof navigator.modelContext.registerTool>[0]) {
    if (!this.isAvailable) return null;
    const reg = navigator.modelContext.registerTool(tool);
    this.registrations.set(tool.name, reg);
    return reg;
  }

  unregister(name: string) {
    this.registrations.get(name)?.unregister();
    this.registrations.delete(name);
  }

  ngOnDestroy() {
    this.registrations.forEach(r => r.unregister());
  }
}
```

```typescript "my.component.ts"
import { Component, OnInit, OnDestroy, inject } from '@angular/core';
import { WebMCPService } from './webmcp.service';

@Component({
  selector: 'app-my',
  template: `<p>Content</p>`
})
export class MyComponent implements OnInit, OnDestroy {
  private webmcp = inject(WebMCPService);

  ngOnInit() {
    this.webmcp.register({
      name: 'my_tool',
      description: 'My tool',
      inputSchema: { type: 'object', properties: {} },
      execute: async () => ({ content: [{ type: 'text', text: 'Done' }] })
    });
  }

  ngOnDestroy() {
    this.webmcp.unregister('my_tool');
  }
}
```

## Common Gotchas

<AccordionGroup>
  <Accordion title="'navigator is not defined' with Angular Universal">
    Use platform checks:
    ```typescript
    constructor(@Inject(PLATFORM_ID) platformId: object) {
      if (isPlatformBrowser(platformId)) {
        // Safe to use navigator
      }
    }
    ```
  </Accordion>

  <Accordion title="Zone.js and async handlers">
    If you need change detection after tool execution, use `NgZone.run()`:
    ```typescript
    execute: async (args) => {
      return this.ngZone.run(() => {
        this.someValue = newValue;
        return { content: [{ type: 'text', text: 'Done' }] };
      });
    }
    ```
  </Accordion>
</AccordionGroup>
