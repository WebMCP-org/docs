---
title: 'Angular Integration'
description: 'Integrate WebMCP tools with Angular. Use services, dependency injection, and signals for reactive tool registration in enterprise Angular applications.'
icon: 'angular'
---

## Overview

Angular's dependency injection and service-based architecture makes it well-suited for WebMCP integration. This guide covers using Angular services, signals (Angular 16+), and RxJS for tool registration with proper lifecycle management.

## How It Works

When you import `@mcp-b/global`, your Angular app starts an **MCP server**:

1. **MCP server starts** - `navigator.modelContext` is initialized with `TabServerTransport`
2. **Tools are registered** - Your services/components call `registerTool()` to expose functionality
3. **AI agents connect** - External agents use `TabClientTransport` to discover and call tools

For Angular Universal (SSR), use `isPlatformBrowser()` to ensure WebMCP code only runs on the client.

## Prerequisites

<Steps>
  <Step title="Install WebMCP">
    ```bash
    npm install @mcp-b/global
    ```
  </Step>

  <Step title="Have Angular configured">
    This guide covers Angular 16+ with signals and standalone components
  </Step>
</Steps>

<Info>
  For schema validation, see [Schemas Guide](/concepts/schemas).
</Info>

## WebMCP Service

Create a centralized service for managing tool registrations:

```typescript "webmcp.service.ts"
import { Injectable, OnDestroy, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import '@mcp-b/global';

interface ToolConfig {
  name: string;
  description: string;
  inputSchema?: Record<string, unknown>;
  handler: (args: Record<string, unknown>) => Promise<unknown>;
}

@Injectable({ providedIn: 'root' })
export class WebMCPService implements OnDestroy {
  private registrations = new Map<string, { unregister: () => void }>();
  private isBrowser: boolean;
  readonly isAvailable: boolean;

  constructor(@Inject(PLATFORM_ID) platformId: object) {
    this.isBrowser = isPlatformBrowser(platformId);
    this.isAvailable = this.isBrowser && 'modelContext' in navigator;
  }

  registerTool(config: ToolConfig): { unregister: () => void } | null {
    if (!this.isAvailable) return null;

    if (this.registrations.has(config.name)) {
      this.unregisterTool(config.name);
    }

    const registration = navigator.modelContext.registerTool({
      name: config.name,
      description: config.description,
      inputSchema: config.inputSchema ?? { type: 'object', properties: {} },
      execute: async (args) => {
        const result = await config.handler(args);
        return {
          content: [{
            type: 'text',
            text: typeof result === 'string' ? result : JSON.stringify(result)
          }]
        };
      }
    });

    this.registrations.set(config.name, registration);
    return registration;
  }

  unregisterTool(name: string): void {
    const reg = this.registrations.get(name);
    if (reg) {
      reg.unregister();
      this.registrations.delete(name);
    }
  }

  ngOnDestroy(): void {
    this.registrations.forEach(r => r.unregister());
  }
}
```

<Info>
  **How AI agents call your tools**: AI agents use `TabClientTransport` to connect to your page and call `client.listTools()` to discover available tools, then `client.callTool()` to execute them. See [Transports](/packages/transports) for details.
</Info>

### Using the Service

```typescript "cart.component.ts"
import { Component, OnInit, OnDestroy, inject } from '@angular/core';
import { WebMCPService } from './webmcp.service';
import { CartService } from './cart.service';

@Component({
  selector: 'app-cart',
  standalone: true,
  template: `
    <div>
      <h2>Cart</h2>
    </div>
  `
})
export class CartComponent implements OnInit, OnDestroy {
  private webmcp = inject(WebMCPService);
  private cartService = inject(CartService);

  ngOnInit() {
    this.webmcp.registerTool({
      name: 'add_to_cart',
      description: 'Add a product to the cart',
      inputSchema: {
        type: 'object',
        properties: {
          productId: { type: 'string' },
          quantity: { type: 'number' }
        },
        required: ['productId']
      },
      handler: async ({ productId, quantity = 1 }) => {
        this.cartService.addItem(productId as string, quantity as number);
        return { success: true, itemCount: this.cartService.itemCount() };
      }
    });
  }

  ngOnDestroy() {
    this.webmcp.unregisterTool('add_to_cart');
  }
}
```

## RxJS Integration

For handlers returning Observables:

```typescript "webmcp-rx.service.ts"
import { Injectable, OnDestroy } from '@angular/core';
import { Observable, firstValueFrom } from 'rxjs';
import '@mcp-b/global';

interface ToolConfig {
  name: string;
  description: string;
  inputSchema?: Record<string, unknown>;
  handler: (args: Record<string, unknown>) => Observable<unknown> | Promise<unknown>;
}

@Injectable({ providedIn: 'root' })
export class WebMCPRxService implements OnDestroy {
  private registrations = new Map<string, { unregister: () => void }>();
  readonly isAvailable = typeof window !== 'undefined' && 'modelContext' in navigator;

  registerTool(config: ToolConfig): void {
    if (!this.isAvailable) return;

    const registration = navigator.modelContext.registerTool({
      name: config.name,
      description: config.description,
      inputSchema: config.inputSchema ?? { type: 'object', properties: {} },
      execute: async (args) => {
        const handlerResult = config.handler(args);
        const result = handlerResult instanceof Observable
          ? await firstValueFrom(handlerResult)
          : await handlerResult;

        return {
          content: [{
            type: 'text',
            text: typeof result === 'string' ? result : JSON.stringify(result)
          }]
        };
      }
    });

    this.registrations.set(config.name, registration);
  }

  unregisterTool(name: string): void {
    this.registrations.get(name)?.unregister();
    this.registrations.delete(name);
  }

  ngOnDestroy(): void {
    this.registrations.forEach(r => r.unregister());
  }
}
```

```typescript "product-search.component.ts"
import { Component, OnInit, OnDestroy, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { FormsModule } from '@angular/forms';
import { map } from 'rxjs/operators';
import { WebMCPRxService } from './webmcp-rx.service';

@Component({
  selector: 'app-product-search',
  standalone: true,
  imports: [FormsModule],
  template: `<input [(ngModel)]="searchQuery" />`
})
export class ProductSearchComponent implements OnInit, OnDestroy {
  private http = inject(HttpClient);
  private webmcp = inject(WebMCPRxService);
  searchQuery = '';

  ngOnInit() {
    this.webmcp.registerTool({
      name: 'search_products',
      description: 'Search products by query',
      inputSchema: {
        type: 'object',
        properties: { query: { type: 'string' } },
        required: ['query']
      },
      handler: ({ query }) => this.http.get<any[]>(`/api/products/search?q=${query}`).pipe(
        map(products => ({ results: products, count: products.length }))
      )
    });
  }

  ngOnDestroy() {
    this.webmcp.unregisterTool('search_products');
  }
}
```

## Directive-Based Registration

Create a directive for declarative registration:

```typescript "webmcp-tool.directive.ts"
import { Directive, Input, OnInit, OnDestroy, OnChanges, SimpleChanges } from '@angular/core';
import '@mcp-b/global';

interface ToolDefinition {
  name: string;
  description: string;
  inputSchema?: Record<string, unknown>;
  handler: (args: Record<string, unknown>) => Promise<unknown>;
}

@Directive({
  selector: '[webmcpTool]',
  standalone: true
})
export class WebMCPToolDirective implements OnInit, OnDestroy, OnChanges {
  @Input('webmcpTool') tool!: ToolDefinition;

  private registration: { unregister: () => void } | null = null;

  ngOnInit() { this.register(); }

  ngOnChanges(changes: SimpleChanges) {
    if (changes['tool'] && !changes['tool'].firstChange) {
      this.unregister();
      this.register();
    }
  }

  ngOnDestroy() { this.unregister(); }

  private register() {
    if (!('modelContext' in navigator) || !this.tool) return;

    this.registration = navigator.modelContext.registerTool({
      name: this.tool.name,
      description: this.tool.description,
      inputSchema: this.tool.inputSchema ?? { type: 'object', properties: {} },
      execute: async (args) => {
        const result = await this.tool.handler(args);
        return {
          content: [{ type: 'text', text: typeof result === 'string' ? result : JSON.stringify(result) }]
        };
      }
    });
  }

  private unregister() {
    this.registration?.unregister();
    this.registration = null;
  }
}
```

## Global Tools

Register app-wide tools in the root component:

```typescript "app.component.ts"
import { Component, OnInit, inject } from '@angular/core';
import { Router } from '@angular/router';
import { WebMCPService } from './webmcp.service';

@Component({
  selector: 'app-root',
  standalone: true,
  template: `
    <nav>
      <a routerLink="/">Home</a>
    </nav>
    <router-outlet></router-outlet>
  `
})
export class AppComponent implements OnInit {
  private webmcp = inject(WebMCPService);
  private router = inject(Router);

  ngOnInit() {
    this.webmcp.registerTool({
      name: 'navigate',
      description: 'Navigate to a page',
      inputSchema: {
        type: 'object',
        properties: { path: { type: 'string' } },
        required: ['path']
      },
      handler: async ({ path }) => {
        await this.router.navigateByUrl(path as string);
        return { navigated: true, path };
      }
    });
  }
}
```

## Common Gotchas

<AccordionGroup>
  <Accordion title="'navigator is not defined' with Angular Universal">
    Use platform checks:

    ```typescript
    import { isPlatformBrowser } from '@angular/common';
    import { PLATFORM_ID, Inject } from '@angular/core';

    constructor(@Inject(PLATFORM_ID) platformId: object) {
      if (isPlatformBrowser(platformId)) {
        // Safe to use navigator
      }
    }
    ```

    See [Framework Gotchas](/ai-frameworks/framework-gotchas) for more SSR patterns.
  </Accordion>

  <Accordion title="Stale data in handlers">
    Read signal values inside the handler:

    ```typescript
    // Good - reads current value
    handler: async () => ({ count: this.count() })
    ```
  </Accordion>

  <Accordion title="Zone.js and async handlers">
    Use `NgZone.run()` if you need change detection:

    ```typescript
    handler: async (args) => {
      return this.ngZone.run(() => {
        this.someSignal.set(newValue);
        return { result: 'done' };
      });
    }
    ```
  </Accordion>
</AccordionGroup>

## Resources

<CardGroup cols={2}>
  <Card title="Angular Docs" icon="angular" href="https://angular.dev">
    Official Angular documentation
  </Card>

  <Card title="Angular Signals" icon="bolt" href="https://angular.dev/guide/signals">
    Guide to Angular signals
  </Card>

  <Card title="Transports" icon="plug" href="/packages/transports">
    TabClientTransport and TabServerTransport reference
  </Card>

  <Card title="AI Frameworks" icon="sparkles" href="/ai-frameworks">
    Integrate with Assistant-UI, AG-UI, or custom runtimes
  </Card>
</CardGroup>
