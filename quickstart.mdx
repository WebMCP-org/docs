---
title: 'Quick Start'
description: 'Add AI agent support to your website in minutes'
icon: 'rocket'
---

Turn your website's JavaScript functions into AI-accessible tools in minutes. This guide will have you up and running with WebMCP quickly.

## Prerequisites

Before you begin, ensure you have:

- **Modern browser**: Chrome, Edge, or Brave (latest version)
- **[MCP-B Extension](https://chromewebstore.google.com/detail/mcp-b-extension/daohopfhkdelnpemnhlekblhnikhdhfa)** installed from Chrome Web Store
- **Node.js 18+** (for NPM installation) or basic HTML knowledge (for script tag method)
- **Package manager**: npm, pnpm, or yarn (optional for NPM method)

## Installation

<Tabs>
  <Tab title="React (Recommended)">
    ```bash
    pnpm add @mcp-b/react-webmcp @mcp-b/global zod
    ```

    ```tsx
    import '@mcp-b/global';
    import { useWebMCP } from '@mcp-b/react-webmcp';
    import { z } from 'zod';

    function MyComponent() {
      useWebMCP({
        name: 'get_page_info',
        description: 'Get current page information',
        inputSchema: {
          includeUrl: z.boolean().optional()
        },
        handler: async ({ includeUrl }) => {
          return {
            title: document.title,
            ...(includeUrl && { url: window.location.href })
          };
        }
      });

      return <div>My Component</div>;
    }
    ```
  </Tab>

  <Tab title="Vanilla JS">
    ```bash
    pnpm add @mcp-b/global
    ```

    ```javascript
    import '@mcp-b/global';

    // Register individual tools (recommended)
    const registration = navigator.modelContext.registerTool({
      name: "get_page_title",
      description: "Get current page title",
      inputSchema: { type: "object", properties: {} },
      async execute() {
        return {
          content: [{ type: "text", text: document.title }]
        };
      }
    });

    // Later, unregister if needed
    // registration.unregister();
    ```
  </Tab>

  <Tab title="Script Tag">
    ```html
    <script src="https://unpkg.com/@mcp-b/global@latest/dist/index.iife.js"></script>
    <script>
      // Register tools using the standard API
      navigator.modelContext.registerTool({
        name: "get_page_title",
        description: "Get current page title",
        inputSchema: { type: "object", properties: {} },
        async execute() {
          return { content: [{ type: "text", text: document.title }] };
        }
      });
    </script>
    ```
  </Tab>
</Tabs>

## Real-World Example

Wrap your existing application logic as tools:

<Tabs>
  <Tab title="React">
    ```tsx
    import { useWebMCP } from '@mcp-b/react-webmcp';
    import { z } from 'zod';

    function ProductPage() {
      useWebMCP({
        name: "add_to_cart",
        description: "Add item to shopping cart",
        inputSchema: {
          productId: z.string(),
          quantity: z.number().min(1)
        },
        handler: async ({ productId, quantity }) => {
          await fetch('/api/cart/add', {
            method: 'POST',
            credentials: 'same-origin',
            body: JSON.stringify({ productId, quantity })
          });
          return { success: true, quantity };
        }
      });

      return <div>Product Page</div>;
    }
    ```
  </Tab>

  <Tab title="Vanilla JS">
    ```javascript
    navigator.modelContext.registerTool({
      name: "add_to_cart",
      description: "Add item to shopping cart",
      inputSchema: {
        type: "object",
        properties: {
          productId: { type: "string" },
          quantity: { type: "number", minimum: 1 }
        },
        required: ["productId", "quantity"]
      },
      async execute({ productId, quantity }) {
        await fetch('/api/cart/add', {
          method: 'POST',
          credentials: 'same-origin',
          body: JSON.stringify({ productId, quantity })
        });
        return {
          content: [{ type: "text", text: `Added ${quantity} items` }]
        };
      }
    });
    ```
  </Tab>
</Tabs>

## Testing

1. Run dev server: `pnpm dev`
2. Open in Chrome with MCP-B extension
3. Click extension icon → Tools tab
4. Test tools via chat or inspector

## Examples

<CardGroup cols={2}>
  <Card
    title="webmcp.sh"
    icon="play"
    href="https://github.com/WebMCP-org/webmcp-sh"
  >
    Production-ready React app with database, navigation, and graph tools
  </Card>

  <Card
    title="Vanilla TypeScript"
    icon="js"
    href="https://github.com/WebMCP-org/examples/tree/main/vanilla-ts"
  >
    Todo app with dynamic tool registration
  </Card>

  <Card
    title="Script Tag"
    icon="code"
    href="https://github.com/WebMCP-org/examples/tree/main/script-tag"
  >
    Zero-config setup with no build tools
  </Card>

  <Card
    title="More Examples"
    icon="folder"
    href="/examples"
  >
    Vue, Nuxt, React Flow, and community examples
  </Card>
</CardGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="✅ Use registerTool() - it just works!">
    For 99% of use cases, use `navigator.modelContext.registerTool()`. It's simple, automatic, and handles cleanup for you.

    ```javascript
    const registration = navigator.modelContext.registerTool({
      name: 'my_tool',
      description: 'What my tool does',
      inputSchema: { /* ... */ },
      async execute(args) { /* ... */ }
    });
    ```
  </Accordion>

  <Accordion title="⚛️ React: Use the useWebMCP() hook">
    React users should use the `useWebMCP()` hook - it handles registration, cleanup, and Zod validation automatically:

    ```tsx
    useWebMCP({
      name: 'my_tool',
      description: 'What it does',
      inputSchema: { amount: z.number() },
      handler: async ({ amount }) => { /* ... */ }
    });
    ```
  </Accordion>

  <Accordion title="🔒 Security first">
    - Only expose tools users can already access via your UI
    - Validate all inputs with schemas
    - Use `credentials: 'same-origin'` for API calls
    - Tools inherit the user's authentication and permissions
  </Accordion>

  <Accordion title="🎨 Tool design tips">
    - Use descriptive names: `add_to_cart`, `search_products`, `update_profile`
    - Wrap existing functions - don't duplicate logic
    - Provide visual feedback when tools execute
    - Return clear success/error messages
  </Accordion>

  <Accordion title="⚠️ When to use provideContext()">
    Only use `provideContext()` for defining base application-level tools. Most developers should stick with `registerTool()`.

    See [Advanced Patterns](/advanced#providecontext-patterns) for details.
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Core Concepts" icon="diagram-project" href="/concepts">
    Understand WebMCP architecture
  </Card>

  <Card title="Examples" icon="code" href="/examples">
    Complete working examples and patterns
  </Card>

  <Card title="React Hooks" icon="react" href="/packages/react-webmcp">
    @mcp-b/react-webmcp package documentation
  </Card>

  <Card title="Security Guide" icon="shield-halved" href="/security">
    Security best practices
  </Card>

  <Card title="NPM Packages" icon="box" href="/packages/global">
    All available packages and APIs
  </Card>

  <Card title="Advanced Patterns" icon="layer-group" href="/advanced">
    Chrome extensions, transports, and more
  </Card>
</CardGroup>

## Related Documentation

- [Core Concepts](/concepts) - Architecture and component interaction
- [Glossary](/glossary) - Key terminology and definitions
- [Security](/security) - Authentication, validation, and best practices
- [Troubleshooting](/troubleshooting) - Common issues and solutions
