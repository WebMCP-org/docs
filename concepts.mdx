---
title: 'Core Concepts'
description: 'Understanding WebMCP architecture, components, and how everything works together'
icon: 'diagram-project'
---

<Note>
  **TL;DR:** WebMCP lets you turn JavaScript functions into AI-accessible tools using `navigator.modelContext.registerTool()`. AI agents can then discover and call these tools to help users interact with your website.
</Note>

## What is WebMCP?

**WebMCP** (Web Model Context Protocol) is a **W3C web standard** currently being incubated by the [Web Machine Learning Community Group](https://www.w3.org/community/webmachinelearning/) that defines how websites expose structured tools to AI agents through the browser's `navigator.modelContext` API.

- **W3C Specification**: [github.com/webmachinelearning/webmcp](https://github.com/webmachinelearning/webmcp)
- **Technical Proposal**: [WebMCP API Proposal](https://github.com/webmachinelearning/webmcp/blob/main/docs/proposal.md)

### Design Philosophy

WebMCP is built on a **human-in-the-loop** philosophy where the human web interface remains primary and AI agents augment (rather than replace) user interaction. This means:

- Users maintain visibility and control over all agent actions
- Tools enable collaborative workflows between humans and AI
- The web page UI remains the primary interaction method

### What WebMCP Is NOT

<Warning>
These use cases are explicitly out of scope for the WebMCP standard.
</Warning>

WebMCP is **not** designed for:

- **Headless browsing** - Requires an active browsing context with the user present
- **Fully autonomous workflows** - Designed for collaborative human-AI interaction, not unsupervised agents
- **Backend service integration** - For server-to-agent communication without a UI, use [MCP](https://modelcontextprotocol.io)
- **UI replacement** - Tools augment the human interface, they don't replace it

### Relationship to MCP

WebMCP is inspired by Anthropic's [Model Context Protocol (MCP)](https://modelcontextprotocol.io) but adapted specifically for web browsers. While WebMCP shares similar concepts with MCP (tools, resources, structured communication), it is evolving as an independent web standard with its own specification path.

#### Key Architectural Decision: SDK vs Transport

The W3C community decided to implement WebMCP as an **SDK/abstraction layer** rather than a pure transport. This architectural choice provides important benefits:

1. **Browser implements WebMCP primitives** - `navigator.modelContext` is a web-native API, not just a message pipe
2. **Protocol independence** - Browsers can maintain backwards compatibility as MCP evolves without breaking existing implementations
3. **Platform-specific security** - Web security models (same-origin policy, CSP) are natively enforced at the browser level
4. **Declarative future** - Enables future declarative APIs (e.g., manifest-based tool registration)

**MCP-B's Role**: The MCP-B packages provide:
1. **W3C API polyfill** - Implements `navigator.modelContext` for browsers that don't yet support it natively
2. **Translation layer** - Bridges between WebMCP's web-native API and the MCP protocol

This dual role allows:
- Tools declared in WebMCP format to work with MCP clients
- Tools declared in MCP format to work with WebMCP browsers
- Version independence as both standards evolve
- Web-specific security features (same-origin policy, CSP)

#### Complementary, Not Competing

Both protocols serve different purposes and can work together:

- **Use MCP** for backend services, server-to-agent communication, headless integrations
- **Use WebMCP** for browser-based tools, user-present workflows, client-side interactions
- Both protocols can coexist in the same application

## Key Components

<CardGroup cols={2}>
  <Card title="W3C Web Model Context API" icon="globe">
    Standard browser API (`navigator.modelContext`) for registering tools - the WebMCP specification
  </Card>

  <Card title="MCP-B Polyfill & Bridge" icon="arrows-left-right">
    Implements navigator.modelContext for current browsers and translates between WebMCP and MCP protocols
  </Card>

  <Card title="Transport Layer" icon="tower-broadcast">
    Communication between browser contexts (tabs, extensions, pages)
  </Card>

  <Card title="MCP-B Extension" icon="puzzle-piece">
    Development and testing tool that collects WebMCP servers from tabs and supports userscript injection
  </Card>
</CardGroup>

## Architecture Overview

### High-Level Architecture

```mermaid
graph TB
    subgraph "Your Website"
        A[JavaScript Code] -->|registerTool| B[navigator.modelContext]
        B -->|Polyfill| C[MCP Bridge]
    end

    subgraph "Browser Layer"
        C -->|Tab Transport| D[MCP-B Extension]
        D -->|Extension Transport| E[AI Agent Interface]
    end

    subgraph "AI Layer"
        E -->|Tool Discovery| F[Available Tools]
        E -->|Tool Execution| G[Call Tool]
        G -->|Response| E
    end

    style A fill:#4B7BFF
    style B fill:#1F5EFF
    style C fill:#1449CC
    style D fill:#FFB84D
    style E fill:#50C878
```

### Component Interaction Flow

```mermaid
sequenceDiagram
    participant W as Website
    participant N as navigator.modelContext
    participant B as MCP Bridge
    participant T as Transport
    participant X as MCP-B Extension
    participant A as AI Agent

    W->>N: registerTool(config)
    N->>B: Store tool definition
    B->>T: Expose via MCP protocol

    A->>X: Request available tools
    X->>T: List tools
    T->>B: Get registered tools
    B-->>X: Return tool list
    X-->>A: Display available tools

    A->>X: Call tool(name, args)
    X->>T: Execute tool
    T->>B: Route to tool handler
    B->>N: Call execute()
    N->>W: Run handler function
    W-->>N: Return result
    N-->>B: Format response
    B-->>T: MCP response
    T-->>X: Tool result
    X-->>A: Show result
```

## Tool Registration

### The Simple Way: `registerTool()`

For most use cases, use `registerTool()` to add tools one at a time:

```javascript
const registration = navigator.modelContext.registerTool({
  name: "add_to_cart",
  description: "Add a product to the shopping cart",
  inputSchema: {
    type: "object",
    properties: {
      productId: { type: "string" },
      quantity: { type: "number" }
    }
  },
  async execute({ productId, quantity }) {
    await addToCart(productId, quantity);
    return {
      content: [{ type: "text", text: `Added ${quantity} items` }]
    };
  }
});

// Optional: Unregister later if needed
registration.unregister();
```

**Why `registerTool()` is the default:**
- ✅ Works everywhere (React, Vue, vanilla JS)
- ✅ Automatic cleanup when unregistered
- ✅ Perfect for component-scoped tools
- ✅ Simple and intuitive

<Accordion title="Advanced: provideContext() for base tools">
  Only use `provideContext()` when you need to set application-level base tools all at once:

  ```javascript
  navigator.modelContext.provideContext({
    tools: [/* array of tool definitions */]
  });
  ```

  **When to use:**
  - Defining core application tools at startup
  - Setting up a foundation tool set

  **Important:** This replaces all base tools each time it's called. For most use cases, stick with `registerTool()` instead.

  See [Advanced Patterns](/advanced) for detailed guidance.
</Accordion>

<AccordionGroup>
  <Accordion title="Implementation Detail: Two-Bucket Tool System">
    WebMCP internally uses a dual-bucket system for tool organization. This is mostly transparent to you, but helps explain how `provideContext()` and `registerTool()` work together:

    ```mermaid
    graph LR
        subgraph "Bucket A: Base Tools"
            A1[App Tool 1]
            A2[App Tool 2]
        end

        subgraph "Bucket B: Dynamic Tools"
            B1[Component Tool 1]
            B2[Component Tool 2]
            B3[Feature Tool 1]
        end

        P[provideContext] -.->|Replaces| A1
        P -.->|Replaces| A2

        R1[registerTool] -->|Adds| B1
        R2[registerTool] -->|Adds| B2
        R3[registerTool] -->|Adds| B3

        B1 -.->|unregister| D1[Removed]

        style A1 fill:#FFB84D
        style A2 fill:#FFB84D
        style B1 fill:#4B7BFF
        style B2 fill:#4B7BFF
        style B3 fill:#4B7BFF
    ```

    **Key behaviors:**
    - Base tools (Bucket A) are replaced when `provideContext()` is called
    - Dynamic tools (Bucket B) persist independently
    - Each `registerTool()` returns an `unregister()` function
    - Tool name collisions throw errors

    **Why this matters:** If you use `provideContext()`, be aware it replaces all base tools. Tools registered with `registerTool()` are unaffected.
  </Accordion>
</AccordionGroup>

## Transport Types

### Tab Transport (In-Page Communication)

For communication within the same browser tab:

```mermaid
graph LR
    A[Web Page MCP Server] <-->|window.postMessage| B[Content Script]
    B <-->|chrome.runtime| C[Extension Background]
    C <-->|MCP Protocol| D[AI Agent]

    style A fill:#4B7BFF
    style B fill:#50C878
    style C fill:#FFB84D
    style D fill:#9B59B6
```

**Use cases:**
- Website exposing tools to extension
- Same-origin communication
- Real-time tool updates

### Extension Transport (Cross-Context)

For communication between extension components:

```mermaid
graph TB
    subgraph "Extension Background"
        A[MCP Hub]
    end

    subgraph "Tab 1"
        B1[Content Script] --> C1[Page MCP Server]
    end

    subgraph "Tab 2"
        B2[Content Script] --> C2[Page MCP Server]
    end

    subgraph "Extension UI"
        D[Sidebar/Popup]
    end

    B1 <-->|Port| A
    B2 <-->|Port| A
    D <-->|Port| A

    style A fill:#FFB84D
    style C1 fill:#4B7BFF
    style C2 fill:#4B7BFF
    style D fill:#50C878
```

**Use cases:**
- Multi-tab tool aggregation
- Extension-to-extension communication
- Centralized tool management

## Tool Lifecycle

### React Component Example

```mermaid
stateDiagram-v2
    [*] --> Mounted: Component mounts
    Mounted --> Registered: useWebMCP() registers tool
    Registered --> Executing: AI calls tool
    Executing --> Registered: Execution complete
    Registered --> Unregistered: Component unmounts
    Unregistered --> [*]

    note right of Registered
        Tool available to AI agents
    end note

    note right of Executing
        Handler function runs
        UI can update
    end note
```

### Vanilla JavaScript Example

```mermaid
stateDiagram-v2
    [*] --> PageLoad: Page loads
    PageLoad --> ToolsRegistered: registerTool() calls
    ToolsRegistered --> Active: Tools discoverable
    Active --> Active: Tools can be called
    Active --> Cleanup: Page unload
    Cleanup --> [*]
```

## Data Flow

Understanding how data flows through WebMCP when AI agents interact with your website tools.

### Tool Execution Flow

The following diagram shows how the extension maintains a fresh tool list and handles AI requests:

```mermaid
sequenceDiagram
    participant W as Your Code
    participant B as MCP Bridge
    participant T as Tab Transport
    participant X as MCP-B Extension
    participant A as AI Agent

    Note over W,X: Tool Registration & Updates
    W->>B: registerTool() / unregister()
    B->>T: Tool list change event
    T->>X: Notify tools changed
    X->>T: Fetch fresh tool list
    T->>B: Query registered tools
    B-->>T: Return tool definitions
    T-->>X: Updated tool list

    Note over X,A: AI Inference Request
    X->>A: Send context with fresh tool list
    A->>A: Analyze available tools

    Note over W,A: Tool Execution Phase
    A->>X: Call tool(name, args)
    X->>T: Execute tool request
    T->>B: Route to tool handler
    B->>W: Run handler function
    W-->>B: Return result data
    B-->>T: Format MCP response
    T-->>X: Tool execution result
    X-->>A: Show result to user
```

## Security Model

### Authentication & Authorization

Tools run in the user's browser context with their existing session:

```mermaid
graph TB
    A[AI Agent Request] --> B{MCP-B Extension}
    B --> C[Content Script]
    C --> D[Website Tool]
    D --> E{Auth Check}
    E -->|Authenticated| F[Execute Tool]
    E -->|Not Authenticated| G[Reject/Login]
    F --> H[Use User's Session]
    H --> I[API Call with Cookies]

    style E fill:#FFB84D
    style H fill:#50C878
    style I fill:#4B7BFF
```

**Security principles:**
- ✅ Tools inherit user authentication
- ✅ Same-origin policy enforced
- ✅ No credential sharing needed
- ✅ Tools respect existing permissions

### Origin Validation

Tab Transport validates origins:

```javascript
new TabServerTransport({
  allowedOrigins: ['https://myapp.com', 'https://api.myapp.com']
  // or ['*'] for development only
});
```

## Extension Architecture

### MCP-B Extension Components

```mermaid
graph TB
    subgraph "MCP-B Extension"
        A[Background Service Worker]
        B[Content Scripts]
        C[Sidebar/Popup UI]
        D[Native Host Bridge]
    end

    subgraph "Web Pages"
        E[Page 1 MCP Server]
        F[Page 2 MCP Server]
    end

    subgraph "Native MCP"
        G[Local MCP Servers]
    end

    B -->|Tab Transport| E
    B -->|Tab Transport| F
    B -->|Extension Transport| A
    C -->|Extension Transport| A
    A -->|Native Messaging| D
    D -->|HTTP/SSE| G

    style A fill:#FFB84D
    style B fill:#50C878
    style C fill:#9B59B6
    style E fill:#4B7BFF
    style F fill:#4B7BFF
    style G fill:#E74C3C
```

## Tool Schema & Validation

### Input Schema (JSON Schema)

```javascript
{
  type: "object",
  properties: {
    userId: {
      type: "string",
      pattern: "^[a-zA-Z0-9]+$",
      description: "User identifier"
    },
    limit: {
      type: "number",
      minimum: 1,
      maximum: 100,
      default: 10
    }
  },
  required: ["userId"]
}
```

### Zod Schema (React)

```typescript
import { z } from 'zod';

const schema = {
  userId: z.string().regex(/^[a-zA-Z0-9]+$/),
  limit: z.number().min(1).max(100).default(10)
};
```

## Best Practices

### Tool Design

<AccordionGroup>
  <Accordion title="Use descriptive names">
    Follow `verb_noun` pattern with domain prefix:
    - ✅ `posts_create`, `graph_navigate`, `db_query`
    - ❌ `doStuff`, `action1`, `helper`
  </Accordion>

  <Accordion title="Provide detailed descriptions">
    Help AI understand when and how to use your tools:
    ```javascript
    description: "Search products by name, category, or SKU. Returns paginated results with stock status."
    ```
  </Accordion>

  <Accordion title="Validate all inputs">
    Use JSON Schema or Zod to enforce types and constraints:
    ```javascript
    inputSchema: {
      productId: z.string().uuid(),
      quantity: z.number().positive().int()
    }
    ```
  </Accordion>

  <Accordion title="Return structured data">
    Use consistent response format:
    ```javascript
    return {
      content: [{ type: "text", text: JSON.stringify(result) }]
    };
    ```
  </Accordion>

  <Accordion title="Handle errors gracefully">
    Provide clear error messages:
    ```javascript
    return {
      content: [{ type: "text", text: "Product not found" }],
      isError: true
    };
    ```
  </Accordion>
</AccordionGroup>

## Performance Considerations

### Tool Registration

- ✅ Register tools once per component lifecycle
- ✅ Unregister when components unmount
- ❌ Don't register/unregister repeatedly
- ❌ Avoid creating too many tools (>50 per page)

### Tool Execution

- ✅ Use async/await for all operations
- ✅ Implement proper error handling
- ✅ Show loading states in UI
- ❌ Don't block the main thread
- ❌ Avoid heavy computations in handlers

## External Standards & Specifications

Learn more about the underlying protocols:

<CardGroup cols={2}>
  <Card title="MCP Specification" icon="book" href="https://modelcontextprotocol.io">
    Official Model Context Protocol documentation from Anthropic
  </Card>

  <Card title="MCP SDK" icon="code" href="https://github.com/modelcontextprotocol/typescript-sdk">
    TypeScript SDK for building MCP servers and clients
  </Card>
</CardGroup>

## Related Resources

<CardGroup cols={2}>
  <Card title="Glossary" icon="book" href="/glossary">
    Key terminology and definitions
  </Card>

  <Card title="Quick Start" icon="rocket" href="/quickstart">
    Get started in minutes
  </Card>

  <Card title="API Reference" icon="code" href="/packages/global">
    Detailed API documentation
  </Card>

  <Card title="Security Guide" icon="shield" href="/security">
    Security best practices
  </Card>
</CardGroup>

## Next Steps

<Steps>
  <Step title="Understand the glossary">
    Review [key terminology](/glossary) used throughout the documentation
  </Step>

  <Step title="Follow the quickstart">
    Build your first WebMCP integration in [Quick Start](/quickstart)
  </Step>

  <Step title="Explore examples">
    See real-world implementations in [Examples](/examples)
  </Step>

  <Step title="Deep dive into packages">
    Learn about specific packages in the [NPM Packages](/packages/global) section
  </Step>
</Steps>
