---
title: 'Tool Design Quick Reference'
description: 'Quick reference for WebMCP tool design patterns. For detailed guidance, see Best Practices.'
icon: 'lightbulb'
---

<Note>
This is a quick reference. For comprehensive guidance with code examples, see [Best Practices for Creating Tools](/best-practices).
</Note>

## Naming Conventions

Use `domain_verb_noun` pattern with clear, descriptive names:

```javascript
// ✅ Good
"products_search"
"cart_add_item"
"user_get_profile"

// ❌ Avoid
"doStuff"
"action1"
"helper"
```

## Descriptions

Tool descriptions go directly to the AI model's context. Include:

- What the tool does and when to use it
- What data it returns and in what format
- Prerequisites or dependencies on other tools
- If execution changes the available tool list

## Input Schema

<AccordionGroup>
  <Accordion title="Clear parameter names">
    Use self-documenting names: `productId`, `quantity`, `addGiftWrap` instead of `id`, `n`, `flag`
  </Accordion>

  <Accordion title="Minimal required parameters">
    Only require what's absolutely necessary. Use defaults for optional parameters.
  </Accordion>

  <Accordion title="Use enums for fixed choices">
    ```javascript
    status: { type: "string", enum: ["pending", "approved", "rejected"] }
    ```
  </Accordion>

  <Accordion title="Include examples in descriptions">
    ```javascript
    dateRange: {
      type: "string",
      description: "Format: YYYY-MM-DD/YYYY-MM-DD (e.g., 2024-01-01/2024-01-31)"
    }
    ```
  </Accordion>
</AccordionGroup>

## Response Format

Return markdown instead of JSON for better AI comprehension:

```javascript
// ✅ Markdown - easier for AI to present
return {
  content: [{
    type: "text",
    text: `# Search Results\n\nFound ${count} products:\n\n${items.map(p => `- **${p.name}** - $${p.price}`).join('\n')}`
  }]
};

// ❌ JSON - harder for AI to parse and present
return {
  content: [{
    type: "text",
    text: JSON.stringify({ success: true, products: items })
  }]
};
```

## Tool Annotations

Mark tool behavior for AI agents:

```javascript
annotations: {
  destructiveHint: true,    // Irreversible action (delete, purchase)
  idempotentHint: true,     // Safe to call multiple times
  readOnlyHint: true        // Only reads data, no modifications
}
```

## Error Handling

Always return structured errors with clear messages:

```javascript
if (!user) {
  return {
    content: [{
      type: "text",
      text: "**Error (USER_NOT_FOUND):** No user found with that ID"
    }],
    isError: true
  };
}
```

## Tool Scope

Design tools around user workflows, not internal architecture. Balance between:

- **Too granular**: `user_set_first_name`, `user_set_last_name` (too many tools)
- **Just right**: `user_update_profile` (reasonable grouping)
- **Too coarse**: `manage_everything` (does too much)

## Quick Checklist

| Aspect | Guideline |
|--------|-----------|
| **Name** | `domain_verb_noun` pattern |
| **Description** | Detailed, includes when to use |
| **Parameters** | Minimal required, clear names, use `.describe()` |
| **Response** | Markdown format, include context |
| **Errors** | Structured with error codes |
| **Annotations** | Mark destructive/readonly operations |

## Related Topics

<CardGroup cols={2}>
  <Card title="Best Practices" icon="star" href="/best-practices">
    Complete guide with detailed examples
  </Card>

  <Card title="Tool Schemas" icon="file-contract" href="/concepts/schemas">
    Input validation and schema design
  </Card>

  <Card title="Tool Registration" icon="screwdriver-wrench" href="/concepts/tool-registration">
    How to register tools
  </Card>

  <Card title="Security Guide" icon="shield" href="/security">
    Security best practices
  </Card>
</CardGroup>
