---
title: "@mcp-b/transports"
description: "Browser-specific transport implementations for Model Context Protocol"
sidebarTitle: "Transports"
icon: "arrows-left-right"
---

Browser-specific MCP `Transport` implementations enabling communication between MCP clients and servers within web pages, browser extensions, user scripts, and native Node.js processes.

## Installation

```bash
npm install @mcp-b/transports @modelcontextprotocol/sdk
```

## Transport Types

### Tab Transports (In-Page Communication)

Use `TabServerTransport` and `TabClientTransport` when your MCP server and client are running in the same browser tab. The transport uses `window.postMessage` for secure communication with origin validation.

### Extension Transports (Cross-Context Communication)

Use `ExtensionClientTransport` and `ExtensionServerTransport` for communication between browser extension components (sidebar, popup, background) and web pages with MCP servers.

### User Script Transports (User Script Communication)

Use `UserScriptClientTransport` and `UserScriptServerTransport` for communication between user scripts and Chrome extensions via the MV3 User Scripts API. Features automatic reconnection to handle background service worker lifecycle.

### Native Transports (Node.js Communication)

Use `NativeClientTransport` and `NativeServerTransport` for communication between Node.js processes and Chrome extensions via Chrome Native Messaging.

## Tab Transport Examples

### Server Setup (Web Page)

Create an MCP server in your web page and expose it via `TabServerTransport`:

```typescript
import { TabServerTransport } from "@mcp-b/transports";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

// Create MCP server with tools
const server = new McpServer(
  {
    name: "TODO-APP",
    version: "1.0.0",
  },
  {
    instructions:
      "You are a helpful assistant that can create, update, and delete todos.",
  }
);

// Register a tool
server.tool(
  "createTodo",
  "Creates a new todo item for the current user",
  {
    todoText: z.string().describe("The content of the todo item."),
  },
  async (args) => {
    // Implementation here
    return {
      content: [
        {
          type: "text",
          text: `Todo created: "${args.todoText}"`,
        },
      ],
    };
  }
);

// Connect to transport with CORS configuration
const transport = new TabServerTransport({
  allowedOrigins: ["*"], // Configure based on your security needs
});
await server.connect(transport);
```

### Client Setup (Same Page)

Connect to the server from within the same page or from an extension content script:

```typescript
import { TabClientTransport } from "@mcp-b/transports";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

// Create transport with target origin
const transport = new TabClientTransport({
  targetOrigin: window.location.origin,
});

// Discover available servers
const availableServers = await transport.discover();
if (availableServers.length > 0) {
  console.log(`Found server: ${availableServers[0].implementation.name}`);
}

// Create and connect client
const client = new Client({
  name: "ExtensionProxyClient",
  version: "1.0.0",
});

await client.connect(transport);

// Use the client
const result = await client.callTool({
  name: "createTodo",
  arguments: { todoText: "Buy groceries" },
});
```

## Extension Transport Examples

### Background Script Setup

The extension background script acts as a hub, aggregating tools from multiple tabs:

```typescript
import { ExtensionServerTransport } from "@mcp-b/transports";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

class McpHub {
  private server: McpServer;

  constructor() {
    this.server = new McpServer({
      name: "Extension-Hub",
      version: "1.0.0",
    });

    this.setupConnections();
  }

  private setupConnections() {
    chrome.runtime.onConnect.addListener((port) => {
      if (port.name === "mcp") {
        this.handleUiConnection(port);
      } else if (port.name === "mcp-content-script-proxy") {
        this.handleContentScriptConnection(port);
      }
    });
  }

  private async handleUiConnection(port: chrome.runtime.Port) {
    const transport = new ExtensionServerTransport(port, {
      keepAlive: true,
      keepAliveInterval: 25_000,
    });
    await this.server.connect(transport);
  }
}
```

### Content Script Bridge

Content scripts act as a bridge between the page's MCP server and the extension:

```typescript
import { TabClientTransport } from "@mcp-b/transports";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

// Connect to the page's MCP server
const transport = new TabClientTransport({
  targetOrigin: window.location.origin,
});

const client = new Client({
  name: "ExtensionProxyClient",
  version: "1.0.0",
});

// Connect to extension background
const backgroundPort = chrome.runtime.connect({
  name: "mcp-content-script-proxy",
});

// Discover and connect to page server
await client.connect(transport);
const pageTools = await client.listTools();

// Register tools with background hub
backgroundPort.postMessage({
  type: "register-tools",
  tools: pageTools.tools,
});

// Handle tool execution requests from background
backgroundPort.onMessage.addListener(async (message) => {
  if (message.type === "execute-tool") {
    const result = await client.callTool({
      name: message.toolName,
      arguments: message.args || {},
    });

    backgroundPort.postMessage({
      type: "tool-result",
      requestId: message.requestId,
      data: { success: true, payload: result },
    });
  }
});
```

### Extension UI Client

Connect from the extension's sidebar or popup to use tools from all connected pages:

```typescript
import { ExtensionClientTransport } from "@mcp-b/transports";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

// Create transport - connects to the extension's background script
const transport = new ExtensionClientTransport({
  portName: "mcp",
});

// Create MCP client
const client = new Client({
  name: "Extension Sidepanel",
  version: "1.0.0",
});

// Connect and use
await client.connect(transport);

// List all available tools from all connected tabs
const tools = await client.listTools();

// Call a tool from a specific website
const result = await client.callTool({
  name: "website_tool_example_com_createTodo",
  arguments: { todoText: "Review PR" },
});
```

## User Script Transport Examples

### Server Extension Setup

Create an MCP server in your Chrome extension's background script that accepts connections from user scripts:

```typescript
import { UserScriptServerTransport } from "@mcp-b/transports";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

// Create MCP server
const server = new McpServer({
  name: "Extension-Server",
  version: "1.0.0",
});

// Listen for user script connections
chrome.runtime.onUserScriptConnect.addListener(async (port) => {
  if (port.name === "mcp") {
    const transport = new UserScriptServerTransport(port, {
      keepAlive: true,
      keepAliveInterval: 25_000,
    });
    await server.connect(transport);
  }
});
```

### User Script Client Setup

Connect from a user script to the extension's MCP server:

```typescript
import { UserScriptClientTransport } from "@mcp-b/transports";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";

// Create transport with automatic reconnection
const transport = new UserScriptClientTransport({
  portName: "mcp",
  autoReconnect: true,
  maxReconnectAttempts: 10,
  reconnectDelay: 1000,
});

// Create MCP client
const client = new Client({
  name: "UserScript",
  version: "1.0.0",
});

// Connect and use
await client.connect(transport);

// List available tools
const tools = await client.listTools();
console.log("Available tools:", tools.tools);

// Call a tool
const result = await client.callTool({
  name: "example_tool",
  arguments: {},
});
```

### User Script Features

- **Automatic Reconnection**: Handles Chrome MV3 service worker lifecycle
- **Exponential Backoff**: Configurable reconnection delays
- **Keep-Alive Support**: Maintains persistent connections
- **Wake Service Worker**: Automatically pings the service worker before reconnecting

## Native Transport Examples

### Native Client (Node.js Process)

Use `NativeClientTransport` in a Node.js process that communicates with a Chrome extension via Native Messaging:

```typescript
import { NativeClientTransport } from "@mcp-b/transports";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import process from "node:process";

// Create transport using stdin/stdout
const transport = new NativeClientTransport(process.stdin, process.stdout);

// Create MCP client
const client = new Client({
  name: "NativeClient",
  version: "1.0.0",
});

// Connect and use
await client.connect(transport);

// Call tools from the extension
const result = await client.callTool({
  name: "extension_tool",
  arguments: { param: "value" },
});
```

### Native Server (Chrome Extension)

Use `NativeServerTransport` in a Chrome extension to accept Native Messaging connections:

```typescript
import { NativeServerTransport } from "@mcp-b/transports";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";

// This would be set up in your background script when receiving native connections
// Note: Chrome extensions handle native messaging through chrome.runtime.connectNative
// The actual connection setup depends on your manifest configuration
```

### Native Transport Features

- **Stdio Communication**: Uses stdin/stdout for IPC
- **Chrome Native Messaging**: Compatible with Chrome's Native Messaging protocol
- **Buffer Management**: Handles message framing and parsing
- **Node.js Only**: Requires Node.js runtime environment

## Configuration Options

### ExtensionServerTransport Options

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `port` | `chrome.runtime.Port` | Yes | Chrome runtime port object |
| `keepAlive` | `boolean` | No | Enable keep-alive ping/pong (default: false) |
| `keepAliveInterval` | `number` | No | Keep-alive interval in ms (default: 30000) |

### ExtensionClientTransport Options

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `portName` | `string` | No | Port name for connection (default: 'mcp') |
| `autoReconnect` | `boolean` | No | Auto-reconnect on disconnect (default: false) |
| `extensionId` | `string` | No | Target extension ID (for cross-extension) |

### UserScriptClientTransport Options

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `extensionId` | `string` | No | Target extension ID (optional for same-extension) |
| `portName` | `string` | No | Port name for connection (default: 'mcp') |
| `autoReconnect` | `boolean` | No | Enable automatic reconnection (default: true) |
| `maxReconnectAttempts` | `number` | No | Maximum reconnection attempts (default: 10) |
| `reconnectDelay` | `number` | No | Initial reconnection delay in ms (default: 1000) |
| `maxReconnectDelay` | `number` | No | Maximum reconnection delay in ms (default: 30000) |
| `reconnectBackoffMultiplier` | `number` | No | Backoff multiplier (default: 1.5) |

### TabServerTransport Options

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `allowedOrigins` | `string[]` | Yes | Array of allowed origins or `['*']` for all |

### TabClientTransport Options

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `targetOrigin` | `string` | Yes | Origin of the target window |

## Key Features

- **Automatic Server Discovery**: Tab clients can discover available servers
- **Cross-Origin Support**: Configure CORS for tab transports
- **Cross-Extension Communication**: Extensions can expose APIs to other extensions
- **User Script Support**: Full MV3 User Scripts API integration with automatic reconnection
- **Native Messaging**: Node.js process communication via stdin/stdout
- **Tool Namespacing**: Extension hub prefixes tools to avoid conflicts
- **Connection Management**: Automatic cleanup when tabs close
- **Keep-Alive Support**: Maintain persistent connections
- **Type Safety**: Full TypeScript support with proper typing

## Security Considerations

- Tab transports respect origin restrictions
- Extension transports use Chrome's secure message passing
- External extension transports require `externally_connectable` manifest configuration
- Server extensions should validate incoming connections from other extensions
- Configure `allowedOrigins` appropriately for your use case
- Tools execute in their original context (web page or extension)
- Native messaging requires manifest configuration and host installation

## Related Packages

- [@modelcontextprotocol/sdk](https://www.npmjs.com/package/@modelcontextprotocol/sdk) - Official MCP SDK
- [@mcp-b/react-webmcp](/packages/react-webmcp) - React hooks for MCP integration
- [@mcp-b/global](/packages/global) - Web Model Context API implementation

## Resources

- [GitHub Repository](https://github.com/WebMCP-org/npm-packages)
- [MCP Protocol Specification](https://modelcontextprotocol.io)
- [Chrome Extension Development](https://developer.chrome.com/docs/extensions)
