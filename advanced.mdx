---
title: 'Advanced Patterns'
description: 'Advanced WebMCP patterns for complex websites and applications'
---

## Dynamic Tool Registration

### Conditional Tools Based on User State

Register tools based on authentication, permissions, or user roles:

```tsx
import { useWebMCP } from '@mcp-b/react-webmcp';
import { useAuth } from './auth';
import { z } from 'zod';

function AdminPanel() {
  const { user } = useAuth();

  // Only register admin tools if user is admin
  useWebMCP({
    name: 'delete_user',
    description: 'Delete a user account (admin only)',
    inputSchema: {
      userId: z.string().uuid()
    },
    handler: async ({ userId }) => {
      if (!user?.isAdmin) {
        throw new Error('Unauthorized');
      }
      await api.users.delete(userId);
      return { success: true };
    },
    // Only register if user is admin
    enabled: user?.isAdmin
  });

  return <div>Admin Panel</div>;
}
```

### Page-Specific Tools

Register different tools based on the current route:

```tsx
import { useWebMCP } from '@mcp-b/react-webmcp';
import { useLocation } from 'react-router-dom';
import { z } from 'zod';

function ProductPage({ productId }) {
  // Product-specific tools only available on this page
  useWebMCP({
    name: 'add_to_cart',
    description: 'Add this product to cart',
    inputSchema: {
      quantity: z.number().min(1).default(1)
    },
    handler: async ({ quantity }) => {
      await addToCart(productId, quantity);
      return { success: true, productId, quantity };
    }
  });

  useWebMCP({
    name: 'get_product_details',
    description: 'Get current product information',
    handler: async () => {
      const product = await fetchProduct(productId);
      return product;
    }
  });

  return <div>Product Page</div>;
}
```

## State Synchronization

### React State Integration

Sync tools with React state for real-time updates:

```tsx
import { useWebMCP } from '@mcp-b/react-webmcp';
import { useState } from 'react';
import { z } from 'zod';

function ShoppingCart() {
  const [items, setItems] = useState([]);
  const [total, setTotal] = useState(0);

  useWebMCP({
    name: 'view_cart',
    description: 'View shopping cart contents',
    handler: async () => {
      return {
        items,
        total,
        itemCount: items.length
      };
    }
  });

  useWebMCP({
    name: 'update_quantity',
    description: 'Update item quantity in cart',
    inputSchema: {
      itemId: z.string(),
      quantity: z.number().min(0)
    },
    handler: async ({ itemId, quantity }) => {
      setItems(prev => {
        if (quantity === 0) {
          return prev.filter(item => item.id !== itemId);
        }
        return prev.map(item =>
          item.id === itemId ? { ...item, quantity } : item
        );
      });
      recalculateTotal();
      return { success: true };
    }
  });

  return <div>Cart UI</div>;
}
```

### Context API Integration

Share tools across component tree:

```tsx
import { createContext, useContext } from 'react';
import { useWebMCP } from '@mcp-b/react-webmcp';

const AppContext = createContext(null);

function AppProvider({ children }) {
  const [state, setState] = useState({});

  useWebMCP({
    name: 'get_app_state',
    description: 'Get current application state',
    handler: async () => {
      return state;
    }
  });

  useWebMCP({
    name: 'update_settings',
    description: 'Update application settings',
    inputSchema: {
      theme: z.enum(['light', 'dark']).optional(),
      language: z.string().optional()
    },
    handler: async (settings) => {
      setState(prev => ({ ...prev, ...settings }));
      return { success: true, settings };
    }
  });

  return (
    <AppContext.Provider value={{ state, setState }}>
      {children}
    </AppContext.Provider>
  );
}
```

## Advanced Validation

### Complex Input Validation

Use Zod for sophisticated validation:

```tsx
import { z } from 'zod';

useWebMCP({
  name: 'create_event',
  description: 'Create a new calendar event',
  inputSchema: {
    title: z.string().min(1).max(100),
    startDate: z.string().datetime(),
    endDate: z.string().datetime(),
    attendees: z.array(z.string().email()).min(1).max(50),
    location: z.string().optional(),
    recurrence: z.object({
      frequency: z.enum(['daily', 'weekly', 'monthly']),
      interval: z.number().min(1).max(365),
      endDate: z.string().datetime().optional()
    }).optional()
  },
  handler: async (event) => {
    // Input is fully validated and typed
    const created = await api.events.create(event);
    return created;
  }
});
```

### Custom Validation Logic

Add business logic validation:

```tsx
useWebMCP({
  name: 'transfer_funds',
  description: 'Transfer funds between accounts',
  inputSchema: {
    fromAccount: z.string(),
    toAccount: z.string(),
    amount: z.number().positive()
  },
  handler: async ({ fromAccount, toAccount, amount }) => {
    // Additional validation beyond schema
    const balance = await getAccountBalance(fromAccount);
    if (balance < amount) {
      throw new Error(`Insufficient funds. Balance: $${balance}`);
    }

    if (fromAccount === toAccount) {
      throw new Error('Cannot transfer to the same account');
    }

    await api.transfer({ fromAccount, toAccount, amount });
    return {
      success: true,
      newBalance: balance - amount
    };
  }
});
```

## Error Handling

### Custom Error Responses

```tsx
useWebMCP({
  name: 'process_order',
  description: 'Process a customer order',
  inputSchema: {
    orderId: z.string()
  },
  handler: async ({ orderId }) => {
    try {
      const order = await api.orders.process(orderId);
      return { success: true, order };
    } catch (error) {
      if (error.code === 'PAYMENT_FAILED') {
        return {
          success: false,
          error: 'Payment failed. Please check your payment method.'
        };
      }
      if (error.code === 'OUT_OF_STOCK') {
        return {
          success: false,
          error: 'Some items are out of stock.'
        };
      }
      throw error; // Re-throw unexpected errors
    }
  },
  onError: (error, input) => {
    // Log errors for monitoring
    analytics.trackError('process_order_failed', {
      error: error.message,
      orderId: input.orderId
    });
  }
});
```

## Performance Optimization

### Debouncing and Throttling

```tsx
import { useMemo } from 'react';
import { debounce } from 'lodash-es';
import { z } from 'zod';

function SearchComponent() {
  const debouncedSearch = useMemo(
    () => debounce(async (query) => {
      return await api.search(query);
    }, 300),
    []
  );

  useWebMCP({
    name: 'search',
    description: 'Search the database',
    inputSchema: {
      query: z.string().min(2)
    },
    handler: async ({ query }) => {
      return await debouncedSearch(query);
    }
  });

  return <div>Search UI</div>;
}
```

### Caching Results

```tsx
import { useRef } from 'react';

function DataComponent() {
  const cache = useRef(new Map());

  useWebMCP({
    name: 'get_user_data',
    description: 'Get user data with caching',
    inputSchema: {
      userId: z.string(),
      skipCache: z.boolean().optional()
    },
    handler: async ({ userId, skipCache }) => {
      if (!skipCache && cache.current.has(userId)) {
        return {
          ...cache.current.get(userId),
          cached: true
        };
      }

      const data = await api.users.get(userId);
      cache.current.set(userId, data);

      // Clear cache after 5 minutes
      setTimeout(() => {
        cache.current.delete(userId);
      }, 5 * 60 * 1000);

      return { ...data, cached: false };
    }
  });

  return <div>User Data</div>;
}
```

## Multi-Step Workflows

### Stateful Multi-Step Operations

```tsx
function CheckoutFlow() {
  const [checkoutState, setCheckoutState] = useState({
    step: 'cart',
    cart: [],
    shipping: null,
    payment: null
  });

  useWebMCP({
    name: 'checkout_next_step',
    description: 'Proceed to next checkout step',
    inputSchema: {
      data: z.record(z.any())
    },
    handler: async ({ data }) => {
      const { step } = checkoutState;

      if (step === 'cart') {
        setCheckoutState(prev => ({
          ...prev,
          step: 'shipping',
          shipping: data
        }));
        return { nextStep: 'shipping' };
      }

      if (step === 'shipping') {
        setCheckoutState(prev => ({
          ...prev,
          step: 'payment',
          payment: data
        }));
        return { nextStep: 'payment' };
      }

      if (step === 'payment') {
        const order = await processOrder(checkoutState);
        setCheckoutState({ step: 'complete', orderId: order.id });
        return { complete: true, orderId: order.id };
      }
    }
  });

  useWebMCP({
    name: 'get_checkout_state',
    description: 'Get current checkout progress',
    handler: async () => checkoutState
  });

  return <div>Checkout Flow</div>;
}
```

## Read-Only Context Tools

### Exposing Application State

```tsx
import { useWebMCPContext } from '@mcp-b/react-webmcp';

function AppLayout() {
  const { pathname } = useLocation();
  const { user } = useAuth();

  // Lightweight read-only context
  useWebMCPContext(
    'context_current_route',
    'Get the current page route and user info',
    () => ({
      path: pathname,
      user: user ? {
        id: user.id,
        name: user.name,
        role: user.role
      } : null,
      timestamp: new Date().toISOString()
    })
  );

  return <div>App Layout</div>;
}
```

## Security Best Practices

### Input Sanitization

```tsx
import DOMPurify from 'dompurify';

useWebMCP({
  name: 'post_comment',
  description: 'Post a comment',
  inputSchema: {
    text: z.string().max(1000),
    postId: z.string().uuid()
  },
  handler: async ({ text, postId }) => {
    // Sanitize HTML content
    const sanitized = DOMPurify.sanitize(text);

    await api.comments.create({
      text: sanitized,
      postId
    });

    return { success: true };
  }
});
```

### Rate Limiting

```tsx
import { useRef } from 'react';

function RateLimitedComponent() {
  const callCount = useRef(new Map());

  const checkRateLimit = (key: string, maxCalls = 10, windowMs = 60000) => {
    const now = Date.now();
    const calls = callCount.current.get(key) || [];
    const recentCalls = calls.filter(time => now - time < windowMs);

    if (recentCalls.length >= maxCalls) {
      throw new Error(`Rate limit exceeded. Try again in ${Math.ceil((windowMs - (now - recentCalls[0])) / 1000)}s`);
    }

    recentCalls.push(now);
    callCount.current.set(key, recentCalls);
  };

  useWebMCP({
    name: 'send_message',
    description: 'Send a message',
    inputSchema: {
      to: z.string(),
      message: z.string()
    },
    handler: async ({ to, message }) => {
      checkRateLimit('send_message', 5, 60000); // 5 per minute

      await api.messages.send({ to, message });
      return { success: true };
    }
  });

  return <div>Messaging</div>;
}
```

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Package Documentation"
    icon="npm"
    href="/packages/global"
  >
    Deep dive into package APIs
  </Card>

  <Card
    title="Examples"
    icon="code"
    href="/examples"
  >
    See complete working examples
  </Card>

  <Card
    title="Troubleshooting"
    icon="wrench"
    href="/troubleshooting"
  >
    Common issues and solutions
  </Card>

  <Card
    title="Discord Community"
    icon="discord"
    href="https://discord.gg/ZnHG4csJRB"
  >
    Get help from the community
  </Card>
</CardGroup>
